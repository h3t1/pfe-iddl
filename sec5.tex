%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Environnement et outils
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Réalisation}

\addcontentsline{toc}{subsection}{Introduction}
\subsection*{Introduction}

Après avoir présenté les différentes étapes de conception et la méthodologie suivie, nous présenterons dans ce chapitre les outils de développement et les différents composants logiciels et matériels, pour lesquels constituent la mise en œuvre effective des différentes tâches du sujet.\\

Le nouveau système d'envoi des notifications fera l'objet d'une démonstration dans la deuxième partie de ce chapitre.
\subsection{Environnements et outils}
L'objectif de cette section est de révéler les principales technologies présentes dans Arkevia, ainsi que celles appliquées lors du développement des différentes solutions. 
\subsubsection{Composants logiciels}
\subsubsubsection{Front-end}
\begin{longtblr}[caption={Technologies utilisées au niveau du front-end}]{
    hlines = {0.25pt,cyan6},
    vlines = {0.25pt,cyan6},
    row{odd} = {bg=cyan9!10!white},
    colsep=4pt,
    rowsep=4pt,
	colspec={cX},
    rowspec={Q[m] Q[m] Q[m] Q[m] Q[m] Q[m]},
}
{
\includegraphics[height=8mm]{images/sec5/bootstrap.pdf}
\\\textbf{Bootstrap}
}
& 
Bootstrap est un framework front-end extrêmement robuste permettant de développer des applications et des sites Web de manière plus rapide et plus conviviale. Il comprend des modèles de conception basés sur HTML et CSS pour les composants d'interface utilisateur courants tels que les formulaires, les boutons, les tableaux, les navigations, les alertes, les onglets et bien d'autres, ainsi que les extensions JavaScript optionnelles.
Bootstrap offre également la possibilité de créer des mises en page réactives (responsive design) avec un effort minimal.\\

{
\includegraphics[height=6mm]{images/sec5/elementui.pdf}\\\textbf{Element UI}
}
& 
Element est une bibliothèque de composants d'interface utilisateur basée sur Vue 2.0 et qui jouit du soutien d'une large communauté. Elle n'est pas seulement destinée aux développeurs front-end, mais fournit également un kit d'interface utilisateur complet avec lequel les concepteurs et les chefs de produit peuvent travailler. Elle est spécifiquement conçue pour la création d'interfaces utilisateur de bureau, mais prend en charge certaines fonctionnalités réactives telles que le masquage des éléments en fonction de la taille de la fenêtre et la création de grilles.
\\

{\includegraphics[height=5.5mm]{images/sec5/jquery.pdf}
 \\\textbf{jQuery}
}
&  
\begin{minipage}{\linewidth}
jQuery est une bibliothèque JavaScript libre créée pour faciliter l'écriture de scripts côté client dans le code HTML des pages web. Elle propose comme principales fonctionnalités :
\raggedright
\begin{itemize}[leftmargin=*]
\item La manipulation du Document Object Model (DOM).
\item La gestion des événements (mouvements de souris, clics, etc.) et de l'AJAX.
\item La création d'effets d'animation.
\item La manipulation des feuilles de style en cascade.
\end{itemize}
\end{minipage}
\\
{\includegraphics[height=5.5mm]{images/sec5/jqueryui.pdf}
 \\\textbf{jQuery UI}
 }
 & 
 \begin{minipage}{\linewidth}
	jQuery UI est une bibliothèque JavaScript basée sur jQuery, fournissant une collection d'éléments utiles au développement d'interfaces utilisateur. Ces éléments comprennent :
    \raggedright
\begin{itemize}[leftmargin=*]
	\item Des interactions comme le "drag \& drop" (glisser-déposer)
	\item Des "widgets" (composants d'interface graphique) telles que les barres de progression, les infobulles, etc.
	\item Des effets pour modifier dynamiquement l'apparence des éléments de l'interface (par exemple, changer la couleur, faire apparaître/disparaître un élément, etc.)
	\item Des thèmes avec des propriétés CSS pour la mise en page des éléments interactifs.
\end{itemize}
\end{minipage}
 \\
 {\includegraphics[height=8mm]{images/sec5/sass.pdf}
 \\\textbf{Sass}
 }
 & Sass (Syntactically Awesome Style Sheets) est une extension de CSS intégrant des fonctionnalités telles que les règles imbriquées, les variables, les mixins et les extensions de classe. Cela permet aux développeurs d'écrire des CSS structurés, lisibles et réutilisables. Sass est compilé en CSS standard. Il s'agit principalement d'un langage de préprocesseur CSS qui accepte à la fois le CSS et sa syntaxe personnalisée d'écriture de codes de conception visuelle.\\
{\includegraphics[width=8mm]{images/sec5/vue.pdf} \\\textbf{VueJs}
} & Vue (prononcé /vju:/, comme le terme anglais view) est un framework évolutif pour construire des interfaces utilisateur. À la différence des autres frameworks monolithiques, Vue a été conçu et pensé pour pouvoir être adopté de manière incrémentale. Le cœur de la bibliothèque se concentre uniquement sur la partie front-end. D’un autre côté, Vue est tout à fait capable de faire tourner des applications web mono-pages quand il est couplé avec des outils modernes et des bibliothèques complémentaires.\\
\end{longtblr}

\subsubsubsection{Back-end}
\begin{longtblr}[caption={Technologies utilisées pour les solutions back-end}]{
    hlines = {0.25pt,azure6},
    vlines = {0.25pt,azure6},
    row{odd} = {bg=azure9!10!white},
    colsep=4pt,
    rowsep=4pt,
	colspec={cX},
    rowspec={Q[m] Q[m] Q[m] Q[m] Q[m] Q[m]},
}
{\includegraphics[height=4.5mm]{images/sec5/hibernate.pdf}
 \\\textbf{Hibernate}
 }
 & Hibernate est une bibliothèque de mappage objet-relationnel (ORM) pour le langage Java permettant aux développeurs d'utiliser des modèles de domaine de style POJO dans leurs applications d'une manière qui va bien au-delà du mappage objet/relationnel.\\
 {\includegraphics[width=7mm]{images/sec5/java.pdf}
 \\\textbf{Java}
 }
 & JAVA est un langage de programmation de haut niveau, orienté objet, fonctionnel, indépendant de la plate-forme et un environnement d'exécution.
 Le langage Java tire une grande partie de sa syntaxe du C et du C++, mais son modèle objet est plus simple que celui de ce dernier et il a moins de facilités de bas niveau. Les applications Java sont généralement compilées en bytecode (appelés fichiers de classe) qui peuvent être exécutés par une JVM (Java Virtual Machine), indépendamment de l'architecture informatique. La JVM compile souvent le code en code machine natif pour optimiser les performances.\\
{
\includegraphics[height=5.5mm]{images/sec5/spring.pdf}
\\\textbf{Spring}
}
& 
Spring est un framework open source fournissant une boite à outils très riche permettant de structurer, d'améliorer et de simplifier l'écriture d'application Java. Spring est également livré avec une variété de modules dédiés à l'exécution de différentes tâches. Certains d'entre eux sont Spring Test, Spring Security, Spring Web, Spring JDBC, Spring AOP, Spring MVC et Spring ORM.\\

{
\includegraphics[height=5.5mm]{images/sec5/spring.pdf}\\\textbf{Spring Batch}
}
& 
Spring Batch est un framework open source basé sur Spring pour permettre le développement d'applications batch qui sont essentielles au fonctionnement quotidien des systèmes d'entreprise. En général, les applications batch font référence à des systèmes automatisés conçus pour traiter des données de masse.
Spring Batch automatise cette itération de base des lots, en offrant la possibilité de traiter des transactions similaires comme un ensemble, souvent dans un environnement isolé, sans aucune interaction avec l'utilisateur.
\\

 {\includegraphics[height=5.5mm]{images/sec5/spring.pdf}
 \\\textbf{Spring Boot}
 }
&  
\begin{minipage}{\linewidth}
Spring Boot permet de créer facilement une application alimentée par Spring avec un minimum d'effort. Une application créée avec Spring Boot peut être :
\raggedright
\begin{itemize}[leftmargin=*]
\item Créée sans requérir aucune configuration xml.
\item Créé sans aucune exigence de serveur d'application puisque Spring Boot fournit un serveur d'application (Tomcat intégré, Jetty ou Undertow).
\item Largement configuré avec quelques valeurs par défaut et des POM de démarrage pour simplifier la configuration Maven du projet.
\item Fournit des solutions prêtes pour la production telles que les métriques, l'intégrité de performance et la configuration externalisée.
\end{itemize}
\end{minipage}
\end{longtblr}
\subsubsubsection{Système de gestion de base de données}
Arkevia est conçu pour fonctionner sur une instance Oracle 10g  (ou plus).\\
Le SGBDR \textbf{Oracle} est utilisé par toutes les applications de la solution ARKEVIA. Il dispose aujourd'hui de l'une des meilleures prestations en termes de performance, de scalabilité et d'administration.
\subsubsubsection{Stockage et sécurité des données}
Le coffre-fort Arkevia est un espace de stockage sécurisé qui repose sur la technologie \textbf{Morpho Secure Storage} de la société \textbf{MORPHO} qui assure :
\begin{itemize}
    \item L'intégrité des documents, au moyen d’une fonction de signature électronique.
    \item La confidentialité des documents, au moyen d’une fonction de chiffrement de données.
    \item La traçabilité des actions effectuées (dépôts, restitutions, demandes de copies, etc.).
    \item Les documents ont ainsi une valeur probante (juridiquement opposable).\\
\end{itemize}
\begin{itemize}[leftmargin=*]
    \item[\textcolor{green5!30!white}{\faCheckCircleO}] Le dépôt ou l'extraction de fichiers ne peut se faire qu'à partir de l'application ARKEVIA, via les Web Services avec authentification SSL Client/Serveur.
    \item[\textcolor{green5!30!white}{\faCheckCircleO}] Les fichiers sont horodatés, signés, chiffrés et stockés dans un espace sécurisé du Datacenter de Cegedim.
    \item[\textcolor{green5!30!white}{\faCheckCircleO}] Le contenu est chiffré avec l'algorithme AES 128 GCM, la clé appartient à Cegedim. Le chiffrement des flux est sécurisé en HTTPS / TLS 1.2 (AES 256) avec un certificat SHA-256 appartenant à Cegedim.
    \item[\textcolor{green5!30!white}{\faCheckCircleO}] Les mots de passe des utilisateurs sont protégés par « hashage » via l'algorithme SHA-256.
\end{itemize}
\subsubsection{Environnement de développement}
\subsubsubsection{Environnement matériel}
Les tâches assignées ont été élaborées sur un ordinateur de bureau conçu pour réaliser les différentes activités liées aux thèmes du stage, soit directement, soit par le biais du protocole RDP. L'ordinateur fourni a les spécifications matérielles et logicielles suivantes :
\begin{itemize}
    \item \textbf{Fabricant} : Dell Inc.
    \item \textbf{Modèle du système} : OptiPlex 7040
    \item \textbf{Processeur} : [01] : Intel64 Family 6 Model 94 Stepping 3 GenuineIntel ~3312 MHz
    \item \textbf{Mémoire physique totale} :  16 309 Mo
    \item \textbf{Système d’exploitation} : Microsoft Windows 10 Professionnel pour les Stations de travail.
\end{itemize}

\subsubsubsection{Environnement logiciel et outils}
Dans cette partie, nous dévoilerons les différents environnements et outils adoptés pour la collaboration, l'échange, la gestion et le suivi des activités, ainsi que pour le développement applicatif des solutions retenues tout au long du processus de développement logiciel. Le tableau suivant (voir tableau ~\ref{tab:elo}) détaille ces environnements et outils par ordre alphabétique :
\begin{longtblr}[caption={Environnements et outils de développement et de collaboration},label={tab:elo}]{
    hlines = {0.25pt,red7},
    vlines = {0.25pt,red7},
    row{odd} = {bg=red9!10!white},
    colsep=4pt,
    rowsep=4pt,
	colspec={cX},
    rowspec={Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m] Q[m]},
}
{
\includegraphics[height=8mm]{images/sec5/confluence.pdf}
\\\textbf{Confluence}
}
& 
Atlassian Confluence est un système de collaboration et de wiki pour les entreprises.
Atlassian Confluence est utilisé pour la collaboration, la gestion de la base de connaissances, la rédaction technique et en tant qu'intranet social ou gestionnaire de documents.\\

{
\includegraphics[height=8mm]{images/sec5/gitlab.pdf}\\\textbf{GitLab}
}
& 
GitLab est une plateforme DevOps complète proposée sous la forme d'une application unique. Elle révolutionne le développement, la sécurité, l'exploitation et la collaboration entre les équipes. 
\\

{\includegraphics[height=7.5mm]{images/sec5/intellijidea.pdf}
 \\\textbf{Intellij IDEA}\\(Ultimate Edition)
}
&  
Intellij IDEA est un IDE complet développé par JetBrains (anciennement « IntelliJ ») axé sur la productivité avec des systèmes d’autocomplétion intelligente, d’analyse de code en temps réel, de refactoring avancé ; l’intégration d’outils de tests et de debugging ; et une pléthore de raccourcis clavier permettant de réaliser rapidement presque toutes les tâches.
\\
{\includegraphics[height=8mm]{images/sec5/jira.pdf}
 \\\textbf{Jira}
 }
 & 
 \begin{minipage}{\linewidth}
	Jira est une plateforme multifonctionnelle qui vise à faciliter la gestion de projet en aidant à suivre les tâches, à identifier les points de blocage et à diffuser l'information entre les différentes parties prenantes.
En pratique, les cas d'utilisation les plus courants de JIRA sont les suivants :
\raggedright
\begin{itemize}[leftmargin=*]
	\item La gestion du support et des activités de développement logiciel.
	\item Le suivi des anomalies.
	\item Le suivi d'activité.
	\item La gestion des centres de services.
\end{itemize}
\end{minipage}
 \\
 {\includegraphics[width=8mm]{images/sec5/excel.pdf} \\\textbf{Microsoft Excel}
} & Microsoft Excel est un logiciel tableur de la suite bureautique Microsoft Office développé et distribué par l'éditeur Microsoft. Il comprend des outils de calcul, de création de graphiques, de tri et de filtrage des données, de création de tableaux croisés dynamiques et un langage de programmation de macros appelé "Visual Basic for Applications". \\
{\includegraphics[width=8mm]{images/sec5/outlook.pdf} \\\textbf{Microsoft Outlook}
} & Microsoft Outlook est un gestionnaire d'informations personnelles de Microsoft (utilisé principalement pour gérer le courrier électronique), disponible à la fois en tant qu'application distincte et en tant que partie de la suite Microsoft Office. Il intègre un client de messagerie, un calendrier (gestionnaire de rendez-vous) et d'autres outils d'organisation des informations personnelles. \\
 {\includegraphics[width=8mm]{images/sec5/powerpoint.pdf}
 \\\textbf{Microsoft}\\\textbf{PowerPoint}
 }
 & PowerPoint est un logiciel de présentation édité par Microsoft. Il est principalement utilisé pour créer des présentations destinées à être projetées. Toutefois, en raison de ses larges aptitudes, il est également utilisé pour l'animation, l'apprentissage en ligne, la diffusion sur le Web, les rapports commerciaux, etc.\\
 {\includegraphics[height=8mm]{images/sec5/oraclesqldeveloper.pdf} \\\textbf{Oracle SQL}\\\textbf{Developer}
} & Oracle SQL Developer est un outil gratuit conçu pour améliorer la productivité et simplifier les tâches de développement des bases de données Oracle. Il s'agit d'un outil graphique entièrement pris en charge pour le développement des bases de données Oracle, y compris le parcours des objets de la base de données, l'exécution des instructions/scripts SQL, la modification et le débogage des instructions PL/SQL. En outre, il est possible d'exécuter un nombre quelconque de rapports fournis, ainsi que de créer et d'enregistrer des rapports personnalisés.\\
{\includegraphics[height=7mm]{images/sec5/postman.pdf} \\\textbf{Postman}
} & Postman est un environnement de développement d'API complet permettant de concevoir, de mocker, de tester, de surveiller et de publier des API à partir de l'interface utilisateur Postman.\\
{\includegraphics[height=7mm]{images/sec5/sonarcube.pdf} \\\textbf{SonarQube}
} & SonarQube est une plateforme open source dédiée à l'analyse et à la mesure en continu de la qualité du code source. Elle permet aux développeurs de détecter les bugs et les vulnérabilités ainsi que de réduire les mauvaises pratiques de code, et de ce fait d'améliorer systématiquement la qualité du code. \\
{\includegraphics[width=7mm]{images/sec5/sourcetree.pdf} \\\textbf{Sourcetree}
} & Développé par Atlassian, SourceTree est un client Git qui intègre très efficacement le workflow Gitflow avec une interface graphique pour gérer presque tout sans avoir à passer par le terminal.\\
{\includegraphics[height=8mm]{images/sec5/wildfly.pdf} \\\textbf{WildFly}
} & WildFly, anciennement connu sous le nom de JBoss Application Server, est un serveur d'applications open source (LGPL), développé par Redhat, pouvant être utilisé sur tout système d'exploitation fournissant une machine virtuelle Java (JVM). \\
{\includegraphics[height=4.5mm]{images/sec5/zoom.pdf} \\\textbf{Zoom}
} & La crise sanitaire et la généralisation du télétravail ont largement encouragé l'adoption des outils de visio-conférence. L'un de ces outils est Zoom, qui est essentiellement un outil permettant aux professionnels de mener facilement des visio-conférences et des réunions en ligne, ainsi que d'échanger des messages, des documents, des images, des vidéos et d'autres types de données avec les participants d'un groupe de discussion.\\
\end{longtblr}
\subsection{Démonstration de la fiabilité du nouveau système d'envoi de notifications}
Le traitement par lot, communément appelé Batch dans le jargon informatique, est une problématique très répandue et quasiment incontournable au sein des entreprises et industries qui manipulent d’énormes masses de données. Dans cette section, nous allons vous présenter à travers un exemple d’application, la technologie Spring Batch/Spring Boot permettant de répondre à ce type de besoin.\\

Le système nouvellement conçu est une application autonome indépendante de l'application mère Arkevia, créée avec Spring Boot, une technologie qui facilite le développement d'applications basées sur Spring, et le framework Spring Batch pour orchestrer le traitement des notifications. Cela n'aurait pas été concevable sans recourir à des paradigmes de programmation avancés tels que le multithreading, qui permet la gestion et l'exécution d'un grand nombre d'instances de manière concurrente, ainsi que les concepts d'inversion de contrôle et d'injection de dépendances, qui facilitent la coordination et le contrôle de l'activité de l'application. Enfin, ce mécanisme a engendré des changements majeurs dans le processus d'extraction et l'exploitation des données, que nous allons expliquer dans la suite de cette section.\\

Le graphique suivant (voir figure \ref{fig:batch}) illustre de manière concrète la relation existant entre les différents composants impliqués dans le batcher lors de son exécution.
\begin{beware}[title=Note : ]
À noter que dans ce framework, lorsque l’on parle de batch on parle plus précisément de Job.
\end{beware}
    
\begin{figure}[!hbt]
    \begin{center}
        \includegraphics[width=\linewidth]{images/sec4/batchdiagram.pdf}
        \caption{Liens entre les divers composants impliqués dans le traitement par lots}
        \label{fig:batch}
    \end{center}
\end{figure}
\begin{itemize}
    \item \textbf{ManagerStep} : Ce composant permet de créer des copies des instances de step de flux basées sur une clé pour distribuer les données des fichiers provenant du Partitioner, également il se base sur le composant \textbf{taskExecutor} et principalement sur la valeur de \lstinline|maxPoolsize| pour définir le nombre maximum de threads à exécuter.
    \item \textbf{Partitioner} : est un composant qui permet de définir un ensemble de valeurs d'entrée sur une collection \lstinline|Map| pour chacun des fichiers existants. En d'autres termes, la logique pour diviser les tâches en threads respectifs va ici.
    \item \textbf{TaskExecutor} : est un JavaBean qui fournit une abstraction autour de l'instance \lstinline|java.util.concurrent.ThreadPoolExecutor| et l'expose en tant que Spring Bean. Grâce à ce composant, vous pouvez configurer le nombre de threads créés, le nombre de threads à conserver dans la file d'attente, le préfixe du thread, etc.
    \item \textbf{WorkerStep} : Représente le flux d'étapes qui seront appliquées et exécutées parallèlement pour accomplir le traitement d'un fichier donné.\\
\end{itemize}
\subsubsubsection*{Analyse du flux de données et traitement par lots}
L'application batch est planifiée par défaut pour s'exécuter automatiquement toutes les deux heures. Une fois le Job est lancé, le composant \textbf{Partitionneur} scanne le répertoire d'entrée afin de trouver des éventuels fichiers csv à traiter ;\\
À ce stade, il y a deux cas :

\begin{enumerate}
    \item Si le répertoire d'entrée \textbf{input} est vide, le programme scanne le répertoire \textbf{inprogress} pour vérifier s'il y a des fichiers qui ne sont pas traités correctement ou s'ils ont été interceptés lors d'une exécution antérieure ou encore bloqués pour un autre motif, dans ce contexte il y a deux hypothèses :
    \begin{enumerate}
        \item \underline{Le répertoire \textbf{inprogress} est vide}, dans ce cas le job se termine avec le statut \textbf{COMPLETED}.
        \item \underline{Le répertoire \textbf{inprogress} n'est pas vide}, dans ce cas le programme reprendra les fichiers CSV trouvés et les traitera une autre fois dans le cadre d'une politique de relance établie (fixée à 3 essais maximum).
    \end{enumerate}
    \item Si le répertoire d'entrée contient des fichiers, le programme créera des instances du Job (threads) pour traiter chaque fichier indépendamment ; le nombre de threads créés dépend de la valeur donnée au programme et du nombre de fichiers trouvés (pour altérer cette valeur, veuillez se référer à la propriété \lstinline|maxPoolSize| dans le fichier application.properties) ; si le nombre de fichiers dépasse le nombre maximum de threads autorisés, les fichiers restants seront ajoutés à la file d'attente (dès qu'un thread sera libre, il prendra en charge un fichier dans la file d'attente).\\
\end{enumerate}
Pour chaque thread lancé, le programme entreprend à différentes phases d'appliquer une série de validations aux fichiers associés afin de gérer efficacement le traitement et les cas de récupération en cas d'échec :
\begin{enumerate}
    \item La première phase est appelée \textbf{step:CSVInProgress}, elle permet de déplacer le fichier courant vers le répertoire \textbf{inprogress}, pour commencer son traitement.
    \item La phase successive est celle du traitement des fichiers CSV, elle constitue le cœur du processus batch et c'est dans cette phase que s'effectuent la lecture, la validation et la transformation des données, et finalement l'envoi des emails pour les données approuvées.
    \item Au terme de la deuxième phase, si le traitement du fichier s'est déroulé avec succès, le fichier sera acheminé à la dernière phase qui est celle de l'archivage du fichier. Dans le cas contraire, le fichier sera ignoré jusqu'à ce que le batch finisse le traitement des fichiers existants dans le répertoire d'entrée \textbf{input}, puis il le reprit ensuite pour un second traitement (fixée à trois tentatives maximum).\\
    \item Tout fichier ayant atteint ce stade d'archivage signifie que le fichier a été traité avec succès et il sera simplement déplacé vers le répertoire \textbf{done} et renommé selon le format suivant file\_name@date\_processing.csv.
    \item À la fin du Job, un email de contrôle incluant le statut de la dernière exécution, le nombre d'emails envoyés par client, ainsi qu'un fichier Excel contenant la liste des utilisateurs auxquels l'email de notification n'a pas été expédié, sera envoyé au responsable.
\end{enumerate}

\subsubsection{Préparation de l'environnement et paramétrage du système}
Afin de préparer la démonstration, nous commencerons par la mise en place de l'environnement d'exécution :
\begin{enumerate}
    \item Établir les données d'entrée : À ce stade, et pour des fins de test, nous allons générer systématiquement quatre fichiers CSV de taille aléatoire. Ces fichiers sont composés de 3 champs :
    \begin{itemize}
        \item \textbf{La matricule} : valeur numérique servant comme identifiant du salarié.
        \item \textbf{Le code client} : valeur alphanumérique servant comme identifiant du client (société).
        \item \textbf{Le IdTech} : valeur alphanumérique servant pour identifier le document déposé.
    \end{itemize}
    \newpage
    Exemple :
    \begin{longtblr}[caption={Exemple de fichiers CSV générés pour le test}]{
        hlines = {0.25pt,azure6},
        vlines = {0.25pt,azure6},
        colsep=4pt,
        rowsep=4pt,
        colspec={XXX},
    }
     \textbf{Matricule}&\textbf{CodeClient}&\textbf{IdTech}\\
    1&CLIENT1&id\_tech\_0jeG8Y\\
    2&CLIENT1&id\_tech\_J99qYD\\
    3&CLIENT1&id\_tech\_8OHcGQ\\
    ...&...&...\\
    100&CLIENT1&id\_tech\_wG1X7C
    \end{longtblr}
    \item Créez trois répertoires portant comme noms "input", "inprogress" et "done".
    \item Déplacez les fichiers CSV préalablement créés dans le répertoire \directory{input} afin de les traiter avec le batcher.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.45\linewidth]{images/sec5/folders.pdf}
    \end{figure}
    \item Assurez-vous que les propriétés \lstinline|folder.input|, \lstinline|folder.inprogress| et \lstinline|folder.done| pointent vers les chemins corrects pour les répertoires \directory{input}, \directory{inprogress} et \directory{done}, respectivement. Pour ce faire, allez consulter le fichier \directory{src/main/ resources/application.properties} et vérifiez les paramètres suivants :\\
\begin{lstlisting}[numbers=none]
folder.input = C:/arkeviavars/input/
folder.inprogress = C:/arkeviavars/inprogress/
folder.done = C:/arkeviavars/done/
\end{lstlisting}
\newpage
\item Vérifiez également d'autres configurations telles que le nombre maximum de threads pouvant être lancés concurremment sur une même exécution ou encore la possibilité d'activer/désactiver le mode de supervision permettant d'envoyer au gestionnaire un rapport détaillé sur l'exécution de chaque fichier abordé. Pour cette manipulation, nous allons activer le mode de supervision, ainsi que spécifier une valeur maximale pour les threads concurrents.\\
\begin{lstlisting}[numbers=none, deletekeywords={true}]
arkevia.monitoring.email = hamza.talaghzi@cegedim-srh.com
mode.monitoring = true
task_executor.core_pool_size = 10
\end{lstlisting}
\end{enumerate}
\subsubsection{Exécution, résultats et interprétations}
\begin{enumerate}
    \item Ouvrez une invite de commande et rendez-vous à la racine du projet.
    \item Afin de rendre la commande \lstinline|mvn| opérationnelle, la variable d'environnement \lstinline|JAVA_HOME| doit pointer vers le répertoire d'installation du JDK \directory{jdk-11.0.X} :\\Entrez \lstinline|set JAVA_HOME =| suivi du chemin du répertoire d'installation JDK et appuyez sur \keys{\return}.
    \item Entrez \lstinline|mvn spring-boot:run| et appuyez sur \keys{\return}.
    \item Lorsque vous exécuterez la commande, vous obtiendrez quelque chose qui ressemble à ceci :\\
\end{enumerate}
\begin{lstlisting}[style=DOS,numbers=left,language=tex, deletekeywords={for,source,test}, morekeywords={certains, logs, sont, omis, par, souci, de, concision}]
    .   ____          _            __ _ _
   /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
  ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
   \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
    '  |____| .__|_| |_|_| |_\__, | / / / /
   =========|_|==============|___/=/_/_/_/
   :: Spring Boot ::                (v2.5.0)

   ---- certains logs sont omis par souci de concision ----

[   scheduling-1] o.s.b.c.l.s.SimpleJobLauncher            : Job: [SimpleJob: [name=notification-manager]] launched with the following parameters: [{supportedClientKeys=SMART;DEMO;CGW;TEST, @=1634983159017}]
[   scheduling-1] c.c.s.n.b.l.JobListener                  : Starting job...
[   scheduling-1] o.s.b.c.j.SimpleStepHandler              : Executing step: [partitionStep]
[ notif@thread-2] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-inprogress]
[ notif@thread-3] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-inprogress]
[ notif@thread-4] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-inprogress]
[ notif@thread-1] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-inprogress]
[ notif@thread-2] o.s.b.c.s.AbstractStep                   : Step: [csv-inprogress] executed in 482ms
[ notif@thread-4] o.s.b.c.s.AbstractStep                   : Step: [csv-inprogress] executed in 476ms
[ notif@thread-3] o.s.b.c.s.AbstractStep                   : Step: [csv-inprogress] executed in 477ms
[ notif@thread-1] o.s.b.c.s.AbstractStep                   : Step: [csv-inprogress] executed in 474ms
[ notif@thread-2] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-processor]
[ notif@thread-4] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-processor]
[ notif@thread-3] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-processor]
[ notif@thread-1] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-processor]
[ notif@thread-2] c.c.s.n.b.BatchConfiguration             : Reading file : C:/arkeviavars/inprogress/client4.csv
[ notif@thread-4] c.c.s.n.b.BatchConfiguration             : Reading file : C:/arkeviavars/inprogress/client3.csv
[ notif@thread-3] c.c.s.n.b.BatchConfiguration             : Reading file : C:/arkeviavars/inprogress/client1.csv
[ notif@thread-1] c.c.s.n.b.BatchConfiguration             : Reading file : C:/arkeviavars/inprogress/client2.csv
[ notif@thread-1] o.s.b.c.s.AbstractStep                   : Step: [csv-processor] executed in 963ms
[ notif@thread-1] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-archiver]
[ notif@thread-1] o.s.b.c.s.AbstractStep                   : Step: [csv-archiver] executed in 476ms
[ notif@thread-1] o.s.b.c.s.AbstractStep                   : Step: [slaveFlow:file1] executed in 4s240ms
[ notif@thread-2] o.s.b.c.s.AbstractStep                   : Step: [csv-processor] executed in 6s45ms
[ notif@thread-2] o.s.b.c.j.SimpleStepHandler              : Duplicate step [csv-archiver] detected in execution of job=[notification-manager]. If either step fails, both will be executed again on restart.
[ notif@thread-2] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-archiver]
[ notif@thread-2] o.s.b.c.s.AbstractStep                   : Step: [csv-archiver] executed in 474ms
[ notif@thread-2] o.s.b.c.s.AbstractStep                   : Step: [slaveFlow:file3] executed in 9s382ms
[ notif@thread-4] o.s.b.c.s.AbstractStep                   : Step: [csv-processor] executed in 13s281ms
[ notif@thread-3] o.s.b.c.s.AbstractStep                   : Step: [csv-processor] executed in 13s278ms
[ notif@thread-4] o.s.b.c.j.SimpleStepHandler              : Duplicate step [csv-archiver] detected in execution of job=[notification-manager]. If either step fails, both will be executed again on restart.
[ notif@thread-4] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-archiver]
[ notif@thread-3] o.s.b.c.j.SimpleStepHandler              : Duplicate step [csv-archiver] detected in execution of job=[notification-manager]. If either step fails, both will be executed again on restart.
[ notif@thread-3] o.s.b.c.j.SimpleStepHandler              : Executing step: [csv-archiver]
[ notif@thread-4] o.s.b.c.s.AbstractStep                   : Step: [csv-archiver] executed in 482ms
[ notif@thread-3] o.s.b.c.s.AbstractStep                   : Step: [csv-archiver] executed in 476ms
[ notif@thread-4] o.s.b.c.s.AbstractStep                   : Step: [slaveFlow:file2] executed in 16s647ms
[ notif@thread-3] o.s.b.c.s.AbstractStep                   : Step: [slaveFlow:file0] executed in 16s933ms
[   scheduling-1] o.s.b.c.s.AbstractStep                   : Step: [partitionStep] executed in 18s94ms
[   scheduling-1] c.c.s.n.b.l.JobListener                  : Job Finished.
\end{lstlisting}
\subsubsubsection*{Interprétations :}
\begin{itemize}
    \item \textbf{Ligne 11} : Démarrage du Job, tout en chargeant certains paramètres qui seront utiles plus tard dans les étapes qui sont exécutées. Ces paramètres ne seront accessibles que dans le contexte du Job.
    \item \textbf{Ligne 13} : Exécution de l'étape de morcellement, cette étape examine le contenu des dossiers \directory{input} et \directory{inprogress} pour déterminer le nombre de fichiers à traiter afin de déduire le nombre de threads nécessaires au traitement de ces fichiers.
    \item \textbf{Lignes 14-17} : Comme nous avons déposé dans cette expérience quatre fichiers CSV dans le dossier \directory{input}, quatre threads ont été créés en conséquence (Les threads sont nommés selon le pattern suivant notif@thread-\textbf{id}) et cela explique pourquoi nous observons dans les logs \lstinline|Executing step : [csv-inprogress]| dupliquée 4 fois. Autrement dit, cela signifie que le batcher applique de manière simultanée la première phase du traitement des fichiers (\lstinline|csv-inprogress|).
    \item \textbf{Lignes 18-21} : Ces logs indiquent que la première phase de traitement des fichiers est terminée.
    \item \textbf{Lignes 22-25} : Ces logs annoncent le début d'une nouvelle phase de traitement des fichiers CSV. Il s'agit de la phase de traitement CSV, qui concrétise le traitement effectif du batch. C'est dans cette étape que s'effectuent la lecture, la validation et la transformation des données, et enfin l'envoi des emails pour les données approuvées.
    \item \textbf{Lignes 23-48} : Ces logs exposent les différentes phases par lesquelles transite chaque fichier, à ce stade vous allez sûrement remarquer qu'il y a des threads qui ont pu passer plus rapidement les étapes et terminer tout le processus avant les autres, cela est dû au fait que chaque fichier a une taille différente et donc des délais d'exécution différents.
    \item \textbf{Ligne 49} : Cette ligne révèle le temps d'exécution total écoulé lors du traitement des fichiers, qui est de 18s94ms. 
    \item \textbf{Ligne 50} : Fin du Job. 
\end{itemize}
Au terme de cette exécution, le superviseur recevra des mails récapitulatifs sur le statut de traitement de chaque fichier. (voir figure \ref{fig:monitoring_mail}).
\begin{figure}[H]
    \includegraphics[width=\linewidth]{images/sec5/monitoring_mail.png}
    \caption{Exemple d'alerte envoyée au superviseur}
    \label{fig:monitoring_mail}
\end{figure}
Par ailleurs, les utilisateurs concernés par les notifications recevront un mail générique les informant du dépôt (voir figure \ref{fig:notification_mail}).
\begin{figure}[H]
    \includegraphics[width=0.95\linewidth]{images/sec5/notification_mail.png}
    \caption{Modèle générique de mail pour l'envoi de notifications}
    \label{fig:notification_mail}
\end{figure}
\subsubsection{Tests unitaires}
Les tests unitaires servent à tester une partie (une unité) d’un système afin de s’assurer qu’il fonctionne correctement (build the system right).\\
Comme Java est un langage orienté Objet, les tests JUnit sont regroupés dans des classes de test. Généralement, on groupe dans une classe les tests ayant la même classe comme point d’entrée et on nomme la classe de test à partir du nom de la classe testée préfixé ou suffixé par Test(s). Par exemple, pour tester la classe \lstinline|FlatFileItemReader|, on créera une classe \lstinline|TestFlatFileItemReader| ou \lstinline|FlatFileItemReaderTests|.
\subsubsubsection*{Exécution des tests JUnit}
L'exécution des tests unitaires se fait via Maven, et plus particulièrement avec le plugin \textbf{maven-surefire}. Une des méthodes pour lancer l'exécution des tests est d'exécuter la commande \lstinline|mvn test| dans le terminal du répertoire parent du projet. Cela permet notamment d'analyser le projet afin de découvrir les classes de test pour ensuite les exécuter.\\
\begin{lstlisting}[style=DOS,numbers=left,language=tex, deletekeywords={for,source,test}, morekeywords={certains, logs, sont, omis, par, souci, de, concision}]
$ mvn test
[INFO] Scanning for projects...
---- certains logs sont omis par souci de concision ----
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running com.cegedim.srh.notification.batch.FlatFileItemReaderTests
---- certains logs sont omis par souci de concision ----
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 10.926 s - in com.cegedim.srh.notification.batch.FlatFileItemReaderTests
[INFO] Running com.cegedim.srh.notification.batch.GedCSVAnalyticsProcessorTests
---- certains logs sont omis par souci de concision ----
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.373 s - in com.cegedim.srh.notification.batch.GedCSVAnalyticsProcessorTests
[INFO] Running com.cegedim.srh.notification.batch.MainApplicationTests
---- certains logs sont omis par souci de concision ----
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.287 s - in com.cegedim.srh.notification.batch.MainApplicationTests
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 7, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  22.359 s
[INFO] Finished at: 2021-11-07T10:17:09+01:00
[INFO] ------------------------------------------------------------------------
\end{lstlisting}
Dans notre cas, les résultats obtenus révèlent que sur un total de 7 tests, il y a eu 7 tests réussis face à 0 test échoué et 0 test ignoré.
\subsubsection{Audit de code}
La vérification d'un ensemble de règles de programmation est généralement faite lors d'une revue de code ou bien d'un audit de code, manuellement ou bien automatiquement afin de trouver les violations de règles de programmation, dans le but de les corriger.\\
Pour cela, nous utiliserons \textbf{SonarQube}, un outil d'analyse statique qui vise à mesurer la qualité du code d’un applicatif. Pour un projet donné, il fournit des métriques portant sur la qualité du code et permet d’identifier précisément les points à corriger (code mort, bugs potentiels, non-respect des standards, carence ou trop-plein de commentaires, etc.).
\begin{beware}[borderline west={5pt}{0pt}{red}, coltitle={red}, title=Remarque : ]
L'analyse SonarQube ne remplace en aucun cas les tests unitaires, mais permet d'identifier rapidement certains défauts du code.
\end{beware}
\subsubsubsection*{Prérequis}
\begin{itemize}
    \item La seule condition préalable à l'exécution de SonarQube est l'installation de Java (Oracle JRE 11 ou OpenJDK 11) sur votre machine.
    \item Installer SonarQube (pour plus de détails, voir \href{https://docs.sonarqube.org/latest/setup/overview/}{la documentation officielle}).
\end{itemize}
\subsubsubsection*{Installation d'une instance locale de SonarQube}
Vous pouvez essayer SonarQube en utilisant une installation traditionnelle avec le fichier zip :
\begin{enumerate}
    \item \href{https://www.sonarqube.org/downloads/}{Téléchargez} le fichier zip de SonarQube Community Edition.
    \item Décompressez-le, dans un emplacement tel que \directory{C:/sonarqube} ou \directory{/opt/sonarqube}.
    \item En tant qu'utilisateur non root, démarrez le serveur SonarQube :
\begin{lstlisting}[numbers=none,language=bash]
# Sous Windows, exécutez :
C:\sonarqube\bin\windows-x86-64\StartSonar.bat

# Sur les autres SE, en tant qu'utilisateur non root, exécutez :
/opt/sonarqube/bin/[OS]/sonar.sh console
\end{lstlisting}
\end{enumerate}
\subsubsubsection*{Mise en place d'une procédure d'analyse de projet}
\begin{enumerate}
    \item Une fois que votre instance est opérationnelle, connectez-vous à \url{http://localhost:9000} en utilisant les informations d'identification de l'administrateur système :
    \begin{itemize}
        \item \textbf{login} : admin
        \item \textbf{mot de passe} : admin
    \end{itemize}
    \item Maintenant que vous êtes connecté à votre instance locale de SonarQube, vous pouvez analyser un projet (Dans notre cas, nous allons poursuivre notre démonstration en appliquant l'analyse Sonar sur le nouveau système d'envoi de notification) :
    \begin{enumerate}
        \item Créez un nouveau projet en choisissant le mode manuel.
        \item Donnez à votre projet une clé de projet et un nom d'affichage et cliquez sur le bouton \textbf{Set Up} (voir figure ~\ref{fig:sonar-1}).
        \begin{figure}[H]
            \begin{center}
                \includegraphics[width=0.75\linewidth]{images/sec5/sonar-1.png}
                \caption{Mise en place d'un projet Sonar}
                \label{fig:sonar-1}
            \end{center} 
        \end{figure}
        \item Pour analyser votre projet localement, cliquez sur le bouton \textbf{Locally}.
        \item Sous \textbf{Provide a token}, sélectionnez \textbf{Generate a token}. Donnez un nom à votre jeton, cliquez sur le bouton \textbf{Generate}, puis cliquez sur \textbf{Continue}.
        \item Sélectionnez la langue principale de votre projet sous \textbf{Run analysis on your project}, et suivez les instructions pour analyser votre projet. 
        \item L'exécution d'une analyse SonarQube avec Maven est très simple. Dans notre cas, il suffit d'exécuter la commande suivante dans le dossier racine du projet :
\begin{lstlisting}[numbers=none,language=bash, deletekeywords={login}]
mvn clean verify sonar:sonar \
-Dsonar.projectKey=nouveau-syst-me-d-envoi-de-notification \
-Dsonar.host.url=http://localhost:9000 \
-Dsonar.login=8c6f1a4ff703b9701af4606125ef587d836e5ef8
\end{lstlisting} 
\end{enumerate}
\end{enumerate}
\subsubsubsection*{Analyse des résultats SonarQube}
Une fois le projet analysé avec succès, nous pouvons consulter le résultat de cette première analyse sur SonarQube. Les résultats de l’analyse seront consultables sur \url{http://localhost:9000/}. Chaque projet dispose d’un espace d’analyse dédié :
\begin{figure}[H]
    \begin{center}
        \includegraphics[width=\linewidth]{images/sec5/sonar-2.png}
        \caption{Résultats récapitulatifs d'analyse SonarQube}
        \label{fig:sonar-2}
    \end{center} 
\end{figure}
SonarQube classe les défauts logiciels selon 3 catégories :
\begin{itemize}
    \item \textbf{Les bugs} : anomalies évidentes du code. Impactent la fiabilité (reliability) de l’application.
    \item \textbf{Les vulnérabilités} : faiblesses du code pouvant nuire au système. Impactent la sécurité de l’application.
    \item \textbf{Les « code smells »} : anti-patrons (ou anti-patterns). Impactent la maintenabilité de l’application.
\end{itemize}
La mention « Passed » signifie que le projet satisfait les exigences minimum définies dans l’espace « Barrières qualité ». Les paramètres par défaut peuvent être adaptés.\\
Pour plus de détails sur les définitions des différentes métriques, veuillez consulter le lien de \href{https://docs.sonarqube.org/latest/user-guide/metric-definitions/}{la documentation officielle}.

\subsubsection{Benchmark}
Dans le cadre de notre étude, le Benchmark réalisé vise à donner une idée sur le temps d'exécution et sa relation avec les méthodes déployées lors de l'exploration des données ainsi que par rapport aux nombres de threads exécutés, il nous permettra par la suite de comparer les pratiques de développement logiciel instaurées dans l'ancien système à celles adoptées dans le nouveau système.\\

Afin d'obtenir des résultats significatifs, nous allons tester les deux systèmes d'envoi de notifications avec un volume de données similaire (\textbf{1052 enregistrements}) et nous mesurerons ensuite le temps d'exécution nécessaire par les deux systèmes pour compléter le traitement de ce volume. Le tableau suivant (voir le tableau \ref{tab:benchmark}) précise les résultats des différentes expériences réalisées ainsi que le temps d'exécution écoulé pour chacune de celles-ci.  
\begin{longtblr}[caption={Comparaison des délais d'exécution entre l'ancien et le nouveau système d'envoi de notifications},label={tab:benchmark}]{
    hlines = {0.25pt,azure6},
    vlines = {0.25pt,azure6},
    colsep=4pt,
    rowsep=4pt,
    rowspec={Q[m] Q[m] Q[m] Q[m]},
    colspec={QX[4]QX[3]X[3]X[3]},
    row{1-4} = {font=\footnotesize}
}
\textbf{Système} & \textbf{Type de données d'entrée}  & \textbf{Occurrences} & \textbf{Nombre de threads} & \textbf{Environnement d'exécution} & \textbf{Temps d'exécution}\\
Ancien & Requête Solr (objet JSON en retour) & 53 appels & 1 & Production & 9min2s\\
Nouveau & Fichier CSV & 1 fichier & 1 & Local & 1min17s\\
Nouveau & Fichier CSV & 10 fichiers & 10 & Local & 21s978ms\\
\end{longtblr}
\subsubsubsection*{Synthèse}
Bien qu'il semble inapproprié de faire ce benchmark, étant donné qu'il existe certaines variables qui pourraient altérer les résultats des tests que nous n'avons pas pris en compte, en particulier l'environnement d'exécution de chacun des systèmes qui était supposé avoir un effet négligeable, ce benchmark a montré qu'il existe un écart important dans les délais obtenus. En effet, le temps d'exécution est passé de \textbf{9min2s} dans l'ancien système à \textbf{1min17s}, soit \textbf{7 fois} plus rapide, et cela, en utilisant uniquement le mode monothread dans le nouveau système ce qui témoigne déjà des améliorations apportées par ce dernier par rapport à l'ancien. En répartissant ce volume sur dix fichiers et en activant le mode multithreading fixé à 10 threads maximum, le temps d'exécution diminue à nouveau vers \textbf{21s987ms}, soit \textbf{25 fois} plus rapide que l'ancien système, ce qui prouve cette fois, l'efficacité et la rentabilité du bon usage du système grâce aux paradigmes du multithreading.
\addcontentsline{toc}{subsection}{Conclusion}
\subsection*{Conclusion}
Dans ce chapitre, nous avons exposé les outils de développement et les différents composants logiciels et matériels étudiés durant toute la période du stage, puis dans une deuxième partie, nous avons abordé la démonstration de l'un des travaux assignés, à savoir le système de notification tout en spécifiant le processus suivi partant de la configuration, l'exécution, les tests unitaires à l'audit de code.
En fait, nous nous sommes efforcés d'implémenter le travail conformément à la conception et aux pratiques préconisées.
Enfin, avec ce chapitre, nous terminons la phase d'implémentation.
%%%%%%%%%%%%%%%%%%
